Этот код на языке C реализует программу с многозадачностью с использованием POSIX-потоков (Pthreads). Он создает два потока, которые работают с общей переменной и выполняют несколько операций. Давайте разберем код подробнее:
./factorial -k 10 -p 2 -m 1000
make -f makefile.txt
### Подключаемые библиотеки
```c
#include <errno.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
```
- **`errno.h`**: содержит определения для кодов ошибок. Используется для обработки ошибок в системе.
- **`pthread.h`**: содержит интерфейс для работы с POSIX-потоками (Pthreads).
- **`stdio.h`**: стандартная библиотека ввода/вывода (например, для функции `printf`).
- **`stdlib.h`**: стандартная библиотека для функций, таких как `exit` (для завершения программы).

### Глобальные переменные
```c
int common = 0; /* A shared variable for two threads */
int r1 = 0, r2 = 0, r3 = 0;
```
- **`common`**: общая переменная, с которой будут работать оба потока. В этом примере потоки будут изменять её значение.
- **`r1`, `r2`, `r3`**: не используются в программе, возможно, они предназначены для будущих расширений.

### Основная функция
```c
int main() {
    pthread_t thread1, thread2;

    if (pthread_create(&thread1, NULL, (void *)do_one_thing, (void *)&common) != 0) {
        perror("pthread_create");
        exit(1);
    }

    if (pthread_create(&thread2, NULL, (void *)do_another_thing, (void *)&common) != 0) {
        perror("pthread_create");
        exit(1);
    }

    if (pthread_join(thread1, NULL) != 0) {
        perror("pthread_join");
        exit(1);
    }

    if (pthread_join(thread2, NULL) != 0) {
        perror("pthread_join");
        exit(1);
    }

    do_wrap_up(common);

    return 0;
}
```
- **`pthread_t thread1, thread2;`**: создаются две переменные для идентификаторов потоков.
- **`pthread_create`**: создаются два потока:
  - Первый поток выполняет функцию `do_one_thing` и передает указатель на переменную `common`.
  - Второй поток выполняет функцию `do_another_thing`, также с указателем на `common`.
  
  Если поток не удается создать, программа выводит ошибку с помощью `perror` и завершает выполнение с кодом 1.

- **`pthread_join`**: используется для того, чтобы основной поток ждал завершения работы обоих потоков. Это важно, чтобы убедиться, что оба потока завершили свою работу перед тем, как продолжить выполнение основной программы. Если возникает ошибка, программа выводит ошибку и завершает выполнение.

- **`do_wrap_up(common);`**: вызывает функцию, которая выводит значение переменной `common` по завершению работы потоков.

### Функции `do_one_thing` и `do_another_thing`
Эти функции выполняют схожие действия, с небольшими отличиями в выводах.

```c
void do_one_thing(int *pnum_times) {
    int i, j, x;
    unsigned long k;
    int work;

    for (i = 0; i < 50; i++) {
        printf("doing one thing\n");
        work = *pnum_times;
        printf("counter = %d\n", work);
        work++; /* increment, but not write */
        for (k = 0; k < 500000; k++); /* long cycle */
        *pnum_times = work; /* write back */
    }
}
```
1. Функция **`do_one_thing`** выполняет 50 итераций:
   - Считывает текущее значение переменной `common` в переменную `work`.
   - Выводит текущее значение переменной `common`.
   - Инкрементирует значение `work` (но пока не записывает в `common`).
   - Далее выполняется цикл для имитации длительной работы, чтобы замедлить выполнение потока.
   - После цикла результат записывается обратно в переменную `common`.

```c
void do_another_thing(int *pnum_times) {
    int i, j, x;
    unsigned long k;
    int work;

    for (i = 0; i < 50; i++) {
        printf("doing another thing\n");
        work = *pnum_times;
        printf("counter = %d\n", work);
        work++; /* increment, but not write */
        for (k = 0; k < 500000; k++); /* long cycle */
        *pnum_times = work; /* write back */
    }
}
```
2. Функция **`do_another_thing`** также выполняет 50 итераций, выполняя те же операции с переменной `common`, но выводит другой текст ("doing another thing").

### Функция завершения работы
```c
void do_wrap_up(int counter) {
    printf("All done, counter = %d\n", counter);
}
```
Эта функция выводит итоговое значение переменной `common` после завершения работы обоих потоков.

### Основные моменты
- **Многозадачность**: Программа использует два потока, которые выполняют одинаковые операции, но с разными выводами.
- **Общая переменная**: Потоки изменяют одну и ту же переменную `common`, и хотя они делают это по очереди, не гарантировано, что их действия будут происходить "синхронно". Программе не хватает механизма синхронизации, чтобы гарантировать правильную работу с переменной, и в реальной ситуации могут возникнуть гонки данных.
- **Итерации и задержка**: Оба потока выполняют по 50 итераций и используют длительный цикл для замедления работы, чтобы можно было наблюдать работу многозадачности.
- **Отсутствие синхронизации**: В коде отсутствует синхронизация, такая как мьютексы, что может привести к проблемам при многократных изменениях общей переменной. Если бы программа использовала синхронизацию, потоки не смогли бы одновременно изменять `common`, что могло бы привести к некорректным результатам.

### Заключение
Программа демонстрирует базовый пример многозадачности в C с использованием потоков. Однако для корректной работы с общей переменной следовало бы добавить механизм синхронизации (например, мьютексы или другие механизмы), чтобы избежать ошибок, связанных с конкурентным доступом к данным.