### 1. **Компилирование программ с помощью GCC**

Для компиляции программ на C с использованием многозадачности через POSIX-потоки (Pthreads), необходимо использовать компилятор **GCC** (GNU Compiler Collection). Для работы с потоками в POSIX необходимо указать флаг для линковки с библиотекой **pthread**.

#### Пример компиляции:
```bash
gcc -o my_program my_program.c -pthread
```
- **`gcc`** — это компилятор C.
- **`-o my_program`** — указывает имя исполнимого файла (в данном случае `my_program`).
- **`my_program.c`** — исходный код программы.
- **`-pthread`** — флаг, который необходим для линковки с библиотекой потоков POSIX (`libpthread`), которая предоставляет интерфейсы для работы с многозадачностью.

Этот флаг сообщает компилятору, что программа будет использовать потоки, и нужно добавить необходимые флаги для линковки.

---

### 2. **Состояние гонки (Race Condition)**

Состояние гонки возникает, когда несколько потоков одновременно пытаются получить доступ к общим данным, и хотя порядок выполнения операций может быть непредсказуемым, из-за этого могут возникнуть ошибки или некорректные результаты. Состояние гонки возникает, когда два или более потока одновременно выполняют операции над одними и теми же данными, и эти операции могут пересекаться.

#### Пример состояния гонки:
```c
int counter = 0;

void* thread_func(void* arg) {
    for (int i = 0; i < 100000; i++) {
        counter++;  // Потоки увеличивают общую переменную
    }
    return NULL;
}

int main() {
    pthread_t thread1, thread2;

    pthread_create(&thread1, NULL, thread_func, NULL);
    pthread_create(&thread2, NULL, thread_func, NULL);

    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);

    printf("Final counter value: %d\n", counter);
    return 0;
}
```
В этом коде **состояние гонки** возникает из-за того, что оба потока одновременно увеличивают переменную `counter`, не синхронизируя доступ. Из-за этого итоговое значение переменной может быть меньше, чем ожидалось (например, 200000 вместо 200000), потому что несколько потоков могут одновременно читать и записывать значение `counter`, создавая конфликт.

#### Как избежать состояния гонки:
Для предотвращения состояния гонки используют механизмы синхронизации, такие как **мьютексы** (`pthread_mutex_t`), чтобы гарантировать, что только один поток имеет доступ к данным в определенный момент времени.

---

### 3. **Критическая секция**

**Критическая секция** — это часть кода, которая выполняется только одним потоком за раз. Чтобы избежать состояния гонки, доступ к критической секции должен быть защищен с помощью механизмов синхронизации, таких как **мьютексы**.

#### Пример с критической секцией:
```c
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void* thread_func(void* arg) {
    for (int i = 0; i < 100000; i++) {
        pthread_mutex_lock(&mutex);  // Вход в критическую секцию
        counter++;  // Работа с общей переменной
        pthread_mutex_unlock(&mutex);  // Выход из критической секции
    }
    return NULL;
}
```
Здесь используется **мьютекс** (`pthread_mutex_lock` и `pthread_mutex_unlock`), чтобы гарантировать, что только один поток может изменять переменную `counter` в одно и то же время. Это устраняет состояние гонки.

---

### 4. **POSIX threads: как создавать, как дожидаться завершения**

#### Создание потока
Для создания нового потока используется функция **`pthread_create`**. Она принимает параметры:
- **`pthread_t *thread`** — указатель на переменную типа `pthread_t`, которая будет хранить идентификатор потока.
- **`const pthread_attr_t *attr`** — атрибуты потока (или `NULL`, если не нужно задавать атрибуты).
- **`void *(*start_routine) (void *)`** — функция, которая будет выполняться в потоке.
- **`void *arg`** — аргумент, передаваемый в функцию потока.

Пример создания потока:
```c
pthread_t thread;
pthread_create(&thread, NULL, thread_func, NULL);
```

#### Ожидание завершения потока
Для того чтобы основной поток дождался завершения работы других потоков, используется функция **`pthread_join`**:
- **`pthread_t thread`** — идентификатор потока, который нужно дождаться.
- **`void **retval`** — указатель на переменную, в которую будет записан результат работы потока (или `NULL`, если результат не нужен).

Пример ожидания завершения потока:
```c
pthread_join(thread, NULL);
```

---

### 5. **Как линковаться на библиотеку pthread**

Для компиляции программы с использованием POSIX-потоков необходимо указать флаг **`-pthread`**, который сообщает компилятору и линковщику, что программа использует библиотеку `pthread`.

#### Пример компиляции:
```bash
gcc -o my_program my_program.c -pthread
```
Этот флаг не только позволяет компилятору правильно обработать код, но и гарантирует, что при линковке будет использована библиотека **libpthread**.

### Подробности флага **`-pthread`**:
- Флаг **`-pthread`** сообщает компилятору о необходимости использовать возможности многозадачности (для POSIX потоков) и обеспечивает правильную настройку линковки.
- Линковка с библиотекой **`libpthread`** предоставляет доступ к функциям для работы с потоками: создание, ожидание, синхронизация и т.д.

---

### Итог
- Для компиляции программ с многозадачностью в C используется флаг **`-pthread`**.
- **Состояние гонки** возникает при одновременном доступе нескольких потоков к общим данным без синхронизации.
- **Критическая секция** — это часть кода, защищенная мьютексами для предотвращения состояния гонки.
- Для создания потоков используется функция **`pthread_create`**, а для ожидания завершения — **`pthread_join`**.
- Для правильной работы с многозадачностью необходимо линковаться с библиотекой **pthread** через флаг **`-pthread`**.


### 1. **POSIX Threads: как создавать и как дожидаться завершения**

**POSIX Threads** (или **Pthreads**) — это стандартная библиотека многозадачности для работы с потоками в системах, совместимых с POSIX (например, Linux, Unix и macOS). В Pthreads потоки выполняются параллельно, и для синхронизации их работы используются различные механизмы, такие как мьютексы, условия и барьеры.

#### Создание потока
Для создания нового потока используется функция **`pthread_create`**:

```c
#include <pthread.h>

void* thread_func(void* arg) {
    // Код, выполняемый в потоке
    return NULL;
}

int main() {
    pthread_t thread;  // Переменная для хранения идентификатора потока

    // Создание потока
    if (pthread_create(&thread, NULL, thread_func, NULL) != 0) {
        perror("pthread_create");
        return 1;
    }

    // Ожидание завершения потока
    if (pthread_join(thread, NULL) != 0) {
        perror("pthread_join");
        return 1;
    }

    return 0;
}
```

##### Объяснение:
- **`pthread_create`**: Функция для создания потока.
    - Первый параметр (`&thread`): указатель на переменную типа `pthread_t`, в которой будет храниться идентификатор потока.
    - Второй параметр (`NULL`): атрибуты потока (если нужно указать дополнительные параметры для потока, например, стек).
    - Третий параметр (`thread_func`): указатель на функцию, которая будет выполняться в потоке.
    - Четвертый параметр (`NULL`): аргумент, передаваемый в функцию потока.
  
- **`pthread_join`**: Функция, которая блокирует главный поток до завершения работы указанного потока.
    - Первый параметр (`thread`): идентификатор потока, который нужно дождаться.
    - Второй параметр (`NULL`): указатель на переменную для получения результата потока (можно передать `NULL`, если результат не нужен).

### 2. **Как линковаться на библиотеку pthread**

Для компиляции программы с использованием **POSIX Threads** необходимо использовать флаг **`-pthread`**, который сообщает компилятору и линковщику, что программа использует многозадачность и необходимо линковать с библиотекой `pthread`.

#### Пример компиляции:
```bash
gcc -o my_program my_program.c -pthread
```

- **`gcc`** — компилятор C.
- **`-o my_program`** — указание имени исполнимого файла.
- **`my_program.c`** — исходный код программы.
- **`-pthread`** — флаг для линковки с библиотекой POSIX-threads.

Этот флаг не только позволяет компилятору правильно обработать код, но и гарантирует, что при линковке будет использована библиотека **`libpthread`**.

### 3. **Как использовать мьютексы**

**Мьютексы** (mutex) — это механизм синхронизации, который гарантирует, что только один поток может выполнять определенную часть кода (критическую секцию) в момент времени. Мьютексы обычно используются для защиты общих ресурсов от конкурентного доступа.

#### Основные операции с мьютексами:
- **`pthread_mutex_init`**: Инициализация мьютекса.
- **`pthread_mutex_lock`**: Захват мьютекса. Поток блокируется, если мьютекс уже захвачен другим потоком.
- **`pthread_mutex_unlock`**: Освобождение мьютекса, чтобы другие потоки могли захватить его.
- **`pthread_mutex_destroy`**: Уничтожение мьютекса (после того, как он больше не нужен).

#### Пример использования мьютекса:

```c
#include <stdio.h>
#include <pthread.h>

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;  // Инициализация мьютекса
int shared_resource = 0;  // Общий ресурс для потоков

void* thread_func(void* arg) {
    // Захват мьютекса
    pthread_mutex_lock(&mutex);
    
    // Работа с общим ресурсом
    shared_resource++;
    printf("Shared resource: %d\n", shared_resource);

    // Освобождение мьютекса
    pthread_mutex_unlock(&mutex);

    return NULL;
}

int main() {
    pthread_t thread1, thread2;

    // Создание двух потоков
    pthread_create(&thread1, NULL, thread_func, NULL);
    pthread_create(&thread2, NULL, thread_func, NULL);

    // Ожидание завершения обоих потоков
    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);

    return 0;
}
```

##### Объяснение:
1. **`pthread_mutex_lock(&mutex)`**: Поток захватывает мьютекс. Если мьютекс уже захвачен другим потоком, поток будет заблокирован, пока мьютекс не будет освобожден.
2. **`shared_resource++`**: Поток выполняет операцию над общим ресурсом. Этот код находится в критической секции, защищенной мьютексом, что гарантирует, что только один поток может модифицировать переменную `shared_resource` в одно время.
3. **`pthread_mutex_unlock(&mutex)`**: Поток освобождает мьютекс, позволяя другим потокам получить доступ к защищенной критической секции.
4. **`pthread_create`**: Создаются два потока, которые выполняют функцию `thread_func`, которая использует мьютекс для синхронизации доступа к общему ресурсу.
5. **`pthread_join`**: Главный поток ожидает завершения обоих потоков.

### Резюме:

1. **Создание потока**: Для создания потока используйте **`pthread_create`**.
2. **Ожидание завершения потока**: Для ожидания завершения потока используйте **`pthread_join`**.
3. **Линковка на библиотеку pthread**: Для компиляции программы с использованием POSIX Threads используйте флаг **`-pthread`** при компиляции.
4. **Использование мьютексов**:
    - Используйте **`pthread_mutex_lock`** и **`pthread_mutex_unlock`** для синхронизации доступа к общим данным.
    - Инициализируйте мьютексы с помощью **`PTHREAD_MUTEX_INITIALIZER`** или **`pthread_mutex_init`** и уничтожайте их с помощью **`pthread_mutex_destroy`**.



### **Что такое Deadlock?**

**Deadlock** (в переводе с английского — "взаимная блокировка") — это ситуация, в которой два или более потока или процесса бесконечно ожидают друг друга, что приводит к тому, что ни один из них не может продолжить выполнение. В результате программы "зависают" и не могут завершить свою работу.

Deadlock возникает, когда выполняются следующие четыре условия одновременно:
1. **Взаимное исключение (Mutual Exclusion)**: Ресурс может быть использован только одним потоком или процессом в одно время.
2. **Удержание и ожидание (Hold and Wait)**: Поток, который уже удерживает хотя бы один ресурс, ожидает дополнительные ресурсы, которые удерживаются другими потоками.
3. **Отсутствие принуждения (No Preemption)**: Ресурсы не могут быть принудительно забраны у потока; их нужно освободить самим потоком.
4. **Циклическое ожидание (Circular Wait)**: Существует цепочка потоков, где каждый поток ожидает ресурс, который удерживает следующий поток в цепочке.

### **Пример Deadlock**

В следующем примере два потока пытаются захватить два мьютекса, но в процессе возникает deadlock, потому что каждый поток удерживает один мьютекс и пытается захватить другой, что приводит к взаимному ожиданию.

```c
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

pthread_mutex_t mutex1 = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t mutex2 = PTHREAD_MUTEX_INITIALIZER;

void* thread1_func(void* arg) {
    pthread_mutex_lock(&mutex1);
    printf("Thread 1: Locked mutex 1\n");

    // Искусственная задержка для создания условия deadlock
    sleep(1);

    printf("Thread 1 trying to lock mutex2\n");
    pthread_mutex_lock(&mutex2);
    printf("Thread 1: Locked mutex 2\n");

    pthread_mutex_unlock(&mutex2);
    pthread_mutex_unlock(&mutex1);

    return NULL;
}

void* thread2_func(void* arg) {
    pthread_mutex_lock(&mutex2);
    printf("Thread 2: Locked mutex 2\n");

    sleep(1);

    printf("Thread 2 trying to lock mutex1\n");
    pthread_mutex_lock(&mutex1);
    printf("Thread 2: Locked mutex 1\n");

    pthread_mutex_unlock(&mutex1);
    pthread_mutex_unlock(&mutex2);

    return NULL;
}

int main() {
    pthread_t thread1, thread2;

    pthread_create(&thread1, NULL, thread1_func, NULL);
    pthread_create(&thread2, NULL, thread2_func, NULL);

    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);

    return 0;
}
```

#### Описание:
1. Поток 1 захватывает `mutex1`, а затем пытается захватить `mutex2`.
2. Поток 2 захватывает `mutex2`, а затем пытается захватить `mutex1`.
3. Поскольку оба потока захватили по одному мьютексу и ожидают друг друга, они попадают в состояние deadlock, и программа "зависает". Потоки не могут продолжить выполнение, так как каждый ждет освобождения ресурса, который удерживает другой поток.

### **Условия для Deadlock**

Как уже упоминалось, для возникновения deadlock необходимы следующие четыре условия:

1. **Взаимное исключение**: Ресурс может быть использован только одним потоком в определенный момент времени.
   - В примере с мьютексами это условие выполнено, поскольку каждый мьютекс может быть заблокирован только одним потоком.

2. **Удержание и ожидание**: Поток удерживает ресурсы, но также ожидает другие ресурсы.
   - Потоки в примере удерживают один мьютекс и ждут другого.

3. **Отсутствие принуждения**: Ресурсы не могут быть забраны у потока насильно, они должны быть освобождены самим потоком.
   - В данном примере мьютексы не могут быть принудительно забраны.

4. **Циклическое ожидание**: Потоки образуют цикл ожидания, где каждый поток ожидает ресурс, который удерживает следующий поток.
   - В этом примере поток 1 ожидает `mutex2`, а поток 2 ожидает `mutex1`, образуя цикл ожидания.

### **Как избежать Deadlock**

Есть несколько способов избежать deadlock в многозадачных приложениях:

1. **Избегать циклического ожидания**:
   - Можно установить строгий порядок захвата мьютексов. Например, все потоки должны захватывать мьютексы в одинаковом порядке, чтобы избежать циклических зависимостей.

2. **Использование тайм-аутов**:
   - Вместо того, чтобы ждать бесконечно, можно установить тайм-аут для захвата мьютекса. Если мьютекс не захвачен в течение определенного времени, поток может сбросить попытку и, например, повторить операцию.

3. **Использование стратегии «пожертвования» (resource preemption)**:
   - Если поток не может получить все ресурсы, он может освободить уже захваченные и попробовать снова, чтобы избежать тупиковых ситуаций.

4. **Использование мьютексов с приоритетом**:
   - В некоторых случаях можно применить стратегию приоритетов, где более важные потоки могут «выталкивать» менее важные.

#### Пример с предотвращением deadlock через порядок захвата мьютексов:

```c
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

pthread_mutex_t mutex1 = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t mutex2 = PTHREAD_MUTEX_INITIALIZER;

void* thread1_func(void* arg) {
    // Захват мьютексов в одном и том же порядке
    pthread_mutex_lock(&mutex1);
    printf("Thread 1: Locked mutex 1\n");

    // Искусственная задержка для создания условия deadlock
    sleep(1);

    pthread_mutex_lock(&mutex2);
    printf("Thread 1: Locked mutex 2\n");

    pthread_mutex_unlock(&mutex2);
    pthread_mutex_unlock(&mutex1);

    return NULL;
}

void* thread2_func(void* arg) {
    // Захват мьютексов в одном и том же порядке
    pthread_mutex_lock(&mutex1);
    printf("Thread 2: Locked mutex 1\n");

    sleep(1);

    pthread_mutex_lock(&mutex2);
    printf("Thread 2: Locked mutex 2\n");

    pthread_mutex_unlock(&mutex2);
    pthread_mutex_unlock(&mutex1);

    return NULL;
}

int main() {
    pthread_t thread1, thread2;

    pthread_create(&thread1, NULL, thread1_func, NULL);
    pthread_create(&thread2, NULL, thread2_func, NULL);

    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);

    return 0;
}
```

В этом примере оба потока захватывают мьютексы в одном и том же порядке (`mutex1`, затем `mutex2`), что предотвращает создание циклического ожидания и, соответственно, deadlock.

### **Вывод**

Deadlock — это серьезная проблема многозадачности, при которой потоки или процессы навсегда блокируются, ожидая друг друга. Чтобы избежать deadlock:
- Строго контролируйте порядок захвата ресурсов.
- Используйте тайм-ауты и другие механизмы для предотвращения зацикливания.
- Разработайте стратегию, которая минимизирует возможность взаимной блокировки в вашем приложении.

