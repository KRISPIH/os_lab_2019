Этот код на языке C реализует многопоточную программу для вычисления факториала числа \( k \) по модулю \( m \), разделяя вычисления между \( p \) потоками. Результат вычисления выводится на экран. Рассмотрим код поэтапно.

---

### **Общая идея программы**
1. Разделить задачу вычисления факториала \( k! \) на \( p \) потоков.
2. Каждый поток вычисляет произведение чисел на своем отрезке.
3. Для объединения результатов используется модульное умножение с защитой от гонок данных (с помощью мьютекса).
4. После завершения всех потоков выводится итоговый результат.

---

### **Детальный разбор кода**

#### 1. **Структура `ThreadData`**
```c
typedef struct {
    int start;            // Начало диапазона для потока
    int end;              // Конец диапазона для потока
    int mod;              // Модуль для вычислений
    long long *result;    // Указатель на общий результат
    pthread_mutex_t *mutex; // Мьютекс для синхронизации
} ThreadData;
```
Эта структура передается каждому потоку и содержит параметры, которые поток будет использовать:
- Диапазон чисел для вычисления факториала.
- Модуль для вычислений.
- Указатель на общий результат, который обновляется всеми потоками.
- Мьютекс для защиты общего ресурса.

---

#### 2. **Функция потока `factorial_mod`**
```c
void *factorial_mod(void *arg) {
    ThreadData *data = (ThreadData *)arg; // Преобразование указателя на структуру
    long long local_result = 1;

    for (int i = data->start; i <= data->end; i++) {
        local_result = (local_result * i) % data->mod; // Локальный результат
    }

    pthread_mutex_lock(data->mutex); // Захват мьютекса
    *data->result = (*data->result * local_result) % data->mod; // Обновление общего результата
    pthread_mutex_unlock(data->mutex); // Освобождение мьютекса

    return NULL;
}
```
Эта функция:
1. Вычисляет факториал для заданного диапазона чисел `[start, end]` с применением модуля `mod`.
2. Сохраняет локальный результат.
3. Обновляет общий результат, защищая доступ с помощью мьютекса.

---

#### 3. **Чтение параметров командной строки**
```c
int k = 0, pnum = 1, mod = 1;
while ((opt = getopt(argc, argv, "k:p:m:")) != -1) {
    switch (opt) {
        case 'k':
            k = atoi(optarg); // Число, для которого вычисляется факториал
            break;
        case 'p':
            pnum = atoi(optarg); // Количество потоков
            break;
        case 'm':
            mod = atoi(optarg); // Модуль
            break;
        default:
            fprintf(stderr, "Usage: %s -k <number> -p <threads> -m <mod>\n", argv[0]);
            exit(EXIT_FAILURE);
    }
}
```
Параметры:
- `-k <число>`: Число \( k \), для которого вычисляется факториал.
- `-p <потоки>`: Количество потоков \( p \).
- `-m <модуль>`: Модуль \( m \) для вычислений.

Если параметры некорректны (например, отрицательные значения), программа завершает выполнение.

---

#### 4. **Инициализация потоков**
```c
pthread_t threads[pnum];        // Массив потоков
ThreadData thread_data[pnum];   // Массив данных для потоков
long long result = 1;           // Итоговый результат
pthread_mutex_t mutex;          // Мьютекс для синхронизации
pthread_mutex_init(&mutex, NULL); // Инициализация мьютекса
```
- Потоки и данные для них инициализируются в массивах.
- `result` используется для хранения итогового результата.
- `mutex` синхронизирует доступ к результату.

---

#### 5. **Разбиение диапазона**
```c
int range = k / pnum;
for (int i = 0; i < pnum; i++) {
    thread_data[i].start = i * range + 1;
    thread_data[i].end = (i == pnum - 1) ? k : (i + 1) * range;
    thread_data[i].mod = mod;
    thread_data[i].result = &result;
    thread_data[i].mutex = &mutex;

    if (pthread_create(&threads[i], NULL, factorial_mod, &thread_data[i]) != 0) {
        perror("Failed to create thread");
        exit(EXIT_FAILURE);
    }
}
```
Диапазон делится равномерно между потоками:
- Каждому потоку присваивается отрезок `[start, end]`.
- Последний поток получает оставшиеся числа (если диапазон не делится нацело).

Для каждого потока:
1. Заполняется структура `ThreadData`.
2. Поток создается вызовом `pthread_create`.

---

#### 6. **Ожидание завершения потоков**
```c
for (int i = 0; i < pnum; i++) {
    pthread_join(threads[i], NULL);
}
```
Главный поток ожидает завершения всех потоков с помощью `pthread_join`.

---

#### 7. **Вывод результата**
```c
printf("Factorial of %d mod %d is: %lld\n", k, mod, result);
```
Итоговый результат вычисляется и выводится.

---

#### 8. **Освобождение ресурсов**
```c
pthread_mutex_destroy(&mutex);
```
Мьютекс уничтожается после завершения работы.

---

### **Пример выполнения**
Запуск программы:
```bash
./factorial -k 10 -p 2 -m 7
```

- \( k = 10 \): Вычисляется \( 10! \).
- \( p = 2 \): Используются 2 потока.
- \( m = 7 \): Вычисления ведутся по модулю 7.

**Разделение работы:**
1. Поток 1: Числа 1–5.
2. Поток 2: Числа 6–10.

**Результаты потоков:**
- Поток 1: \((1 \cdot 2 \cdot 3 \cdot 4 \cdot 5) \mod 7 = 3\).
- Поток 2: \((6 \cdot 7 \cdot 8 \cdot 9 \cdot 10) \mod 7 = 6\).

**Объединение:**
\((3 \cdot 6) \mod 7 = 4\).

**Вывод:**
```
Factorial of 10 mod 7 is: 4
```

---

### **Преимущества**
- Поддержка многопоточности ускоряет вычисления для больших \( k \).
- Использование модуля предотвращает переполнение.
- Мьютекс защищает общий ресурс от гонок данных.

### **Недостатки**
- Небольшой накладной расход на создание и синхронизацию потоков.
- Необязательно равномерное распределение работы при \( k \% p \neq 0 \).

Этот код демонстрирует эффективное использование многопоточности для вычислений.